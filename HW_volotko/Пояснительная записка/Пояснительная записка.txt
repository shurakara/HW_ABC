Пояснительная записка:

1. Полученное задание: разработать консольное приложение, работающее с контейнером обощенных объемных(трехмерных) 

геометрических фигур представляемых Шаром(радиус), Правильный тетраэдр(сторона), Параллелепипед(три стороны). С

общей переменной плотности и функцией вычисления объема(заменил на переменную, тк высчитывать каждый раз объем при 

сортировке не эффективно, виртуальной и общей для всех альтернатив сделал функцию print вывода). Так же для 

полученного контейнера необходимо было реализовать функцию шейкерной сортировки.  

Данные аргументов программы: 

	Для ввода теста из файла: -f in.txt out1.txt out2.txt

		где out1.txt out2.txt - файлы выходных данных, 2 - сортированныей контейнер по объему

		in.txt - файл с тестовами данными описывающими фигуры по нижеописанному примеру: 

		Ввод тестовых данных из файла:

		Ввод одного объекта производиться в 2 строки. В первой указывается какой именно это объект, а

		во второй его параметры. 

		Шар: 

    			первая строка: 1

    			вторая строка: R D(где R - целочисленный, радиус, D - плотность, дествительное)

		Правильный тетраэдр: 

    			первая строка: 2

    			вторая строка: A D(где A - целочисленный, сторона, D - плотность, дествительное)

		Параллелепипед: 

    			первая строка: 3

    			вторая строка: A B C D(где A, B, C - целочисленный, стороны, D - плотность, дествительное)

	Данные для генерации фигур: -n k out1.txt out2.txt

		k - количество фигур от 1 до 10000.



Структурная схема: 

Типы: 

class container 280004 байта

int len 4 байта

shape cont 28 * 10000 = 280000 байт





class shape 16 байт{

double Density 8 байт

double Volume 8 байт

}



class sphere : shape 20 байт{

int A 4 байта

}





class parallelepiped : shape 28 байт{

int A, B, C 12 байт

}



class tetrahedron : shape 20 байт{

int R 4 байта

}





Память: 

main{

int argc 4 байта

char* argv[] 8 байт

int start 4 байта

int end 4 байта

container с 280004 байт

int size 4 байта

}



InRnd{

int size 4 байта

}



ShakerSort{

int left 4 байта

int right 4 байта 

int add 4 байта

Shape sp 28 байт

}



~container{

int i 4 байта

}



Shape::In{

int k, a, b, c, d 20 байт

наследник Shape 28 байт

}



stack:

main



container::In//container::InRnd

Shape::In//Shape::InRnd

Shape::In//Shape::InRnd end

container::In//container::InRnd end



Shape::print 

Shape::print end



container::ShakerSort

container::ShakerSort end



Shape::print 

Shape::print end



main end




Основные характеристики программы: 

  число интерфейсных модулей (заголовочных файлов) : 6

  модулей реализации (фалов с определением программных объектов): 5

  общий размер исходных текстов: ~1Мб

  время выполнения программы для различных тестовых наборов данных:

    тест 1 : 183 мс - 2 элемента

    тест 2 : 233 мс - 6 элементов

    тест 3 : 166 мс - 7 элементов

    тест 4 : 274 мс - 9 элементов

    тест 5 : 277 мс - 14 элементов

    тест 6 : 205 мс - 17 элементов

    тест 7 : 179 мс - 20 элементов

    тест 8 : 266 мс - 50 элементов(генерируемый)

    тест 9 : 353 мс - 100 элементов(генерируемый)

    тест 10: 1858 мс - 500 элементов(генерируемый)

    тест 11: 4937 мс - 1000 элементов(генерируемый)

    тест 12: 94377 мс - 5000 элементов(генерируемый)

    тест 13: 408722 мс - 10000 элементов(генерируемый)

Сравнение с процедурным подходом:

Процедурный подход направлен на определение методов  "на все случаи жизни" и среди них 

путаешься даже при правильной декомпозиции. ООП же всесторонне облегчает применение и ограничивает круг использования 

методов. Каждый метод используется только в связке с тем объектом, к которому принадлежит. 

Прослеживается, что функций в процедурном подходе становиться слишком много и в них можно ошибочно передать все что угодно, 

а ООП предлагает строгую взаимосвязь методов и использования. Строгая взаимосвязь(типизированность) предлагает меньше 

вариантов развития событий и написание кода становится примитивнее, но и ошибиться сложнее в некоторых моментах.

Больше внимания уделяется взаимосвязям. Тоже касается всех функциональных членов. 

Появляется и другой "синтаксический сахар" как конструкторы и деструкторы(даже без их фактического написания),

когда в процедурном подходе это отдельные и самостоятельные методы.